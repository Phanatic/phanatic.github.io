<!DOCTYPE html>
<html>
  <head>
    <title>Customizing Serialization of Entities in the ADO.NET Data Services Client Library – Phani Raj – Technical Lead at HP Cloud</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="This post is inspired by this forum thread :Data services client -- exception on saveChanges
Problem Statement 

I have added some custom proeprties to the Entity Types Generated by DataSvcUtil.exe /Add Service Reference / Hand Coded , these properties do not exist on the server and should not be sent to the server . When I try to save an object of a Type which has custom client-Side only properties to the Data Service using AddObject and SaveChanges, I get the following error :
Error processing request stream. The property name '{PropertyName}' specified for type '{TypeName} is not valid
This error is basically from the server telling the client library that its sending a payload which does not seem to match the definition of the Entity Type on the server. 
We can solve this problem by customizing the Payload that the client generates when it sends the entity to the server. The DataServiceContext exposes an event called WritingEntity that is fired right before we send the payload over the wire.
Its argumentlist contains ReadingWritingEntityEventArgs which gives you access to the Entity Instance being Serialized ( e.Entity )&nbsp; and the ATOM Payload (e.Data ) we are about to send to the Server.
Removing a property from the ATOM Payload that is being sent to the server.
void dataContext_WritingEntity(object sender, ReadingWritingEntityEventArgs e) {

    // e.Data gives you the XElement for the Serialization of the Entity 
    //Using XLinq  , you can  add/Remove properties to the element Payload  
    XName xnEntityProperties = XName.Get("properties", e.Data.GetNamespaceOfPrefix("m").NamespaceName);
    XElement xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
   //The XName of the property we are going to remove from the payload
    XName xnProperty = XName.Get(“{PropertyName}”, e.Data.GetNamespaceOfPrefix("d").NamespaceName);

    //Get the Property of the entity  you don't want sent to the server
    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
    //Remove this property from the Payload sent to the server 
     xeRemoveThisProperty.Remove();

     }
}
Generalizing this further , we want to make it easier to customize the serialization of multiple entity types without having to write multiple copies of the WritingEntity event handler. We will add an attribute that specfies that a certain CLR property should not be serialized in the ATOM Payload when the client library sends the entity to the server.
    /// &lt;summary&gt;
    /// Properties marked with this Attribute are not serialized in the payload when sent to the server
    /// &lt;/summary&gt;
    [AttributeUsage(AttributeTargets.Property)]
    public class DoNotSerializeAttribute : Attribute
    {
    }
Now , we change the WritingEntity Event handler to remove any property&nbsp; that has this attribute on it . 
        void DataServiceContextEx_WritingEntity(object sender, ReadingWritingEntityEventArgs e)
        {
            // e.Data gives you the XElement for the Serialization of the Entity 
            //Using XLinq  , you can  add/Remove properties to the element Payload  
            XName xnEntityProperties = XName.Get("properties", e.Data.GetNamespaceOfPrefix("m").NamespaceName);
            XElement xePayload = null;
            foreach (PropertyInfo property in e.Entity.GetType().GetProperties())
            {
                object[] doNotSerializeAttributes = property.GetCustomAttributes(typeof(DoNotSerializeAttribute), false);
                if (doNotSerializeAttributes.Length &gt; 0)
                {
                    if (xePayload == null)
                    {
                        xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
                    }
                    //The XName of the property we are going to remove from the payload
                    XName xnProperty = XName.Get(property.Name, e.Data.GetNamespaceOfPrefix("d").NamespaceName);
                    //Get the Property of the entity  you don't want sent to the server
                    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
                    //Remove this property from the Payload sent to the server 
                    xeRemoveThisProperty.Remove();
                }
            }
        }
We can encapsulate this functionality into its own class and any DataServiceContext type that inherits from this class should be able to inherit this functionality too . Complete Source Code :

Using this in your applications : 
Create a partial class with the same name as shown above and include it in your application to get this behavior.
Attribute your types with the DoNotSerializeAttribute&nbsp; attribute so that this property is not serialized. 
 public class TestType
    {
        public int ID { get; set; }
        /// &lt;summary&gt;
        /// This Property is client-only , should not be sent to the server
        /// &lt;/summary&gt;
        [DoNotSerialize]
        public string ClientOnlyProperty { get; set; }
    }
" />
    <meta property="og:description" content="This post is inspired by this forum thread :Data services client -- exception on saveChanges
Problem Statement 

I have added some custom proeprties to the Entity Types Generated by DataSvcUtil.exe /Add Service Reference / Hand Coded , these properties do not exist on the server and should not be sent to the server . When I try to save an object of a Type which has custom client-Side only properties to the Data Service using AddObject and SaveChanges, I get the following error :
Error processing request stream. The property name '{PropertyName}' specified for type '{TypeName} is not valid
This error is basically from the server telling the client library that its sending a payload which does not seem to match the definition of the Entity Type on the server. 
We can solve this problem by customizing the Payload that the client generates when it sends the entity to the server. The DataServiceContext exposes an event called WritingEntity that is fired right before we send the payload over the wire.
Its argumentlist contains ReadingWritingEntityEventArgs which gives you access to the Entity Instance being Serialized ( e.Entity )&nbsp; and the ATOM Payload (e.Data ) we are about to send to the Server.
Removing a property from the ATOM Payload that is being sent to the server.
void dataContext_WritingEntity(object sender, ReadingWritingEntityEventArgs e) {

    // e.Data gives you the XElement for the Serialization of the Entity 
    //Using XLinq  , you can  add/Remove properties to the element Payload  
    XName xnEntityProperties = XName.Get("properties", e.Data.GetNamespaceOfPrefix("m").NamespaceName);
    XElement xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
   //The XName of the property we are going to remove from the payload
    XName xnProperty = XName.Get(“{PropertyName}”, e.Data.GetNamespaceOfPrefix("d").NamespaceName);

    //Get the Property of the entity  you don't want sent to the server
    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
    //Remove this property from the Payload sent to the server 
     xeRemoveThisProperty.Remove();

     }
}
Generalizing this further , we want to make it easier to customize the serialization of multiple entity types without having to write multiple copies of the WritingEntity event handler. We will add an attribute that specfies that a certain CLR property should not be serialized in the ATOM Payload when the client library sends the entity to the server.
    /// &lt;summary&gt;
    /// Properties marked with this Attribute are not serialized in the payload when sent to the server
    /// &lt;/summary&gt;
    [AttributeUsage(AttributeTargets.Property)]
    public class DoNotSerializeAttribute : Attribute
    {
    }
Now , we change the WritingEntity Event handler to remove any property&nbsp; that has this attribute on it . 
        void DataServiceContextEx_WritingEntity(object sender, ReadingWritingEntityEventArgs e)
        {
            // e.Data gives you the XElement for the Serialization of the Entity 
            //Using XLinq  , you can  add/Remove properties to the element Payload  
            XName xnEntityProperties = XName.Get("properties", e.Data.GetNamespaceOfPrefix("m").NamespaceName);
            XElement xePayload = null;
            foreach (PropertyInfo property in e.Entity.GetType().GetProperties())
            {
                object[] doNotSerializeAttributes = property.GetCustomAttributes(typeof(DoNotSerializeAttribute), false);
                if (doNotSerializeAttributes.Length &gt; 0)
                {
                    if (xePayload == null)
                    {
                        xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
                    }
                    //The XName of the property we are going to remove from the payload
                    XName xnProperty = XName.Get(property.Name, e.Data.GetNamespaceOfPrefix("d").NamespaceName);
                    //Get the Property of the entity  you don't want sent to the server
                    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
                    //Remove this property from the Payload sent to the server 
                    xeRemoveThisProperty.Remove();
                }
            }
        }
We can encapsulate this functionality into its own class and any DataServiceContext type that inherits from this class should be able to inherit this functionality too . Complete Source Code :

Using this in your applications : 
Create a partial class with the same name as shown above and include it in your application to get this behavior.
Attribute your types with the DoNotSerializeAttribute&nbsp; attribute so that this property is not serialized. 
 public class TestType
    {
        public int ID { get; set; }
        /// &lt;summary&gt;
        /// This Property is client-only , should not be sent to the server
        /// &lt;/summary&gt;
        [DoNotSerialize]
        public string ClientOnlyProperty { get; set; }
    }
" />
    
    <meta name="author" content="Phani Raj" />

    
    <meta property="og:title" content="Customizing Serialization of Entities in the ADO.NET Data Services Client Library" />
    <meta property="twitter:title" content="Customizing Serialization of Entities in the ADO.NET Data Services Client Library" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Phani Raj - Technical Lead at HP Cloud" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/barryclark/jekyll-now/master/images/jekyll-logo.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Phani Raj</a></h1>
            <p class="site-description">Technical Lead at HP Cloud</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Customizing Serialization of Entities in the ADO.NET Data Services Client Library</h1>

  <div class="entry">
    <p>This post is inspired by this forum thread :<a href="http://social.msdn.microsoft.com/Forums/en-US/adodotnetdataservices/thread/b7a9e01d-c5c2-4478-8f01-00f7f6e0f75f" target="_blank" mce_href="http://social.msdn.microsoft.com/Forums/en-US/adodotnetdataservices/thread/b7a9e01d-c5c2-4478-8f01-00f7f6e0f75f">Data services client -- exception on saveChanges</a></p>
<h4>Problem Statement </h4>
<p></p>
<p>I have added some custom proeprties to the Entity Types Generated by DataSvcUtil.exe /Add Service Reference / Hand Coded , <br />these properties do not exist on the server and should not be sent to the server . <br />When I try to save an object of a Type which has custom client-Side only properties to the Data Service using AddObject and SaveChanges, <br />I get the following error :</p>
<pre class="csharpcode">Error processing request stream. The property name <span class="str">'{PropertyName}'</span> specified <span class="kwrd">for</span> type '{TypeName} <span class="kwrd">is</span> not valid</pre>
<p>This error is basically from the server telling the client library that its sending a payload which does not seem to match the definition <br />of the Entity Type on the server. </p>
<p>We can solve this problem by customizing the Payload that the client generates when it sends the entity to the server. <br />The DataServiceContext exposes an event called <a href="http://msdn.microsoft.com/en-us/library/system.data.services.client.dataservicecontext.writingentity.aspx" target="_blank" mce_href="http://msdn.microsoft.com/en-us/library/system.data.services.client.dataservicecontext.writingentity.aspx">WritingEntity</a> that is fired right before we send the payload over the wire.</p>
<p>Its argumentlist contains <a href="http://msdn.microsoft.com/en-us/library/system.data.services.client.readingwritingentityeventargs.aspx" target="_blank" mce_href="http://msdn.microsoft.com/en-us/library/system.data.services.client.readingwritingentityeventargs.aspx">ReadingWritingEntityEventArgs</a> which gives you access to the Entity Instance being Serialized ( e.Entity )&nbsp; <br />and the ATOM Payload (e.Data ) we are about to send to the Server.</p>
<h5>Removing a property from the ATOM Payload that is being sent to the server.</h5>
<pre class="darkcsharpcode"><span class="kwrd">void</span> dataContext_WritingEntity(<span class="kwrd">object</span> sender, ReadingWritingEntityEventArgs e) {

    <span class="rem">// e.Data gives you the XElement for the Serialization of the Entity </span>
    <span class="rem">//Using XLinq  , you can  add/Remove properties to the element Payload  </span>
    XName xnEntityProperties = XName.Get(<span class="str">"properties"</span>, e.Data.GetNamespaceOfPrefix(<span class="str">"m"</span>).NamespaceName);
    XElement xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
   <span class="rem">//The XName of the property we are going to remove from the payload</span>
    XName xnProperty = XName.Get(“{PropertyName}”, e.Data.GetNamespaceOfPrefix(<span class="str">"d"</span>).NamespaceName);

    <span class="rem">//Get the Property of the entity  you don't want sent to the server</span>
    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
    <span class="rem">//Remove this property from the Payload sent to the server </span>
     xeRemoveThisProperty.Remove();

     }
}</pre>
<p>Generalizing this further , we want to make it easier to customize the serialization of multiple entity types without having to write <br />multiple copies of the WritingEntity event handler. <br />We will add an attribute that specfies that a certain CLR property should not be serialized in the ATOM Payload when the client library <br />sends the entity to the server.</p>
<pre class="darkcsharpcode">    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// Properties marked with this Attribute are not serialized in the payload when sent to the server</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    [AttributeUsage(AttributeTargets.Property)]
    <span class="kwrd">public</span> <span class="kwrd">class</span> DoNotSerializeAttribute : Attribute
    {
    }</pre>
<p>Now , we change the WritingEntity Event handler to remove any property&nbsp; that has this attribute on it . </p>
<pre class="darkcsharpcode">        <span class="kwrd">void</span> DataServiceContextEx_WritingEntity(<span class="kwrd">object</span> sender, ReadingWritingEntityEventArgs e)
        {
            <span class="rem">// e.Data gives you the XElement for the Serialization of the Entity </span>
            <span class="rem">//Using XLinq  , you can  add/Remove properties to the element Payload  </span>
            XName xnEntityProperties = XName.Get(<span class="str">"properties"</span>, e.Data.GetNamespaceOfPrefix(<span class="str">"m"</span>).NamespaceName);
            XElement xePayload = <span class="kwrd">null</span>;
            <span class="kwrd">foreach</span> (PropertyInfo property <span class="kwrd">in</span> e.Entity.GetType().GetProperties())
            {
                <span class="kwrd">object</span>[] doNotSerializeAttributes = property.GetCustomAttributes(<span class="kwrd">typeof</span>(DoNotSerializeAttribute), <span class="kwrd">false</span>);
                <span class="kwrd">if</span> (doNotSerializeAttributes.Length &gt; 0)
                {
                    <span class="kwrd">if</span> (xePayload == <span class="kwrd">null</span>)
                    {
                        xePayload = e.Data.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnEntityProperties).First&lt;XElement&gt;();
                    }
                    <span class="rem">//The XName of the property we are going to remove from the payload</span>
                    XName xnProperty = XName.Get(property.Name, e.Data.GetNamespaceOfPrefix(<span class="str">"d"</span>).NamespaceName);
                    <span class="rem">//Get the Property of the entity  you don't want sent to the server</span>
                    XElement xeRemoveThisProperty = xePayload.Descendants().Where&lt;XElement&gt;(xe =&gt; xe.Name == xnProperty).First&lt;XElement&gt;();
                    <span class="rem">//Remove this property from the Payload sent to the server </span>
                    xeRemoveThisProperty.Remove();
                }
            }
        }</pre>
<p>We can encapsulate this functionality into its own class and any DataServiceContext type that inherits from this class should be able to <br />inherit this functionality too . <br />Complete Source Code :</p>
<p><script src="http://gist.github.com/113147.js" mce_src="http://gist.github.com/113147.js"></script></p>
<h4>Using this in your applications : </h4>
<p>Create a partial class with the same name as shown above and include it in your application to get this behavior.</p>
<p>Attribute your types with the DoNotSerializeAttribute&nbsp; attribute so that this property is not serialized. </p>
<pre class="darkcsharpcode"> <span class="kwrd">public</span> <span class="kwrd">class</span> TestType
    {
        <span class="kwrd">public</span> <span class="kwrd">int</span> ID { get; set; }
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// This Property is client-only , should not be sent to the server</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        [DoNotSerialize]
        <span class="kwrd">public</span> <span class="kwrd">string</span> ClientOnlyProperty { get; set; }
    }</pre>

  </div>

  <div class="date">
    Written on December 11, 2008
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/jekyllrb"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
