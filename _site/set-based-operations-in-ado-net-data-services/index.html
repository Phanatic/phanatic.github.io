<!DOCTYPE html>
<html>
  <head>
    <title>Set Based Operations in Ado.net Data Services – Phani Raj – Technical Lead at HP Cloud</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="Today's Post is co-Authored by Linq Ninja and my Colleague MarceloLinq to Astoria does not support Set based queries , which means that this query is invalid
List&lt;string&gt; citiesIWillVisit = new List&lt;string&gt;(){
                        "London",
                        "Berlin",
                        "Prague"
                        };
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; citiesIWillVisit.Contains(cx.City));
The above example would use the IN operator to search for a property ina given set of values.You can achieve the same query using Dynamic Linq Queries to filter over a set of values by creating Dynamic Linq Queries at runtime based on your logic and Set .Lets take the same example as before .Of all the Customers in the Northwind store , lets say that you want to visit customers living in citiesthatare on your itinerary.

 List&lt;object&gt; citiesIWillVisit = new List&lt;object&gt;(){
                        "London",
                        "Berlin",
                        "Prague"
                        };
The Customer Entity contains a property called "City" on which we want to filter.if you already know the cities and they wont change , a normal Filter query would look like this 
            //Create the Northwind Client Context
            northwindContext nwContext = new northwindContext(
                new Uri("http://ServiceEndPoint/Northwind.svc")
                );

            var customersAround = from cx in nwContext.Customers
                                  where cx.City == "London"
                                  || cx.City == "Berlin"
                                  || cx.City == "Prague"
                                  select cx;

            foreach (Customers coHabitant in customersAround) {
                System.Console.WriteLine(coHabitant.ContactName);
            }
Now , what if the cities you visit is dynamic ? In such a case you cannot write queries for all possible combinations and expect it to work.Its just too wasteful to do that , there is a better way to do this , Dynamic Filter Expressions.Once you have a dynamic filter expression, you can call the "Where" method on the appropriate DataServiceQuery&lt;T&gt; object to get the results. Lets look at how to build a dynamic filter expression.An Expression has the following basic components.
nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; cx.City == "London")
Parameter : "cx"Left Hand Side Of Expression : cx.CityConstant : "London"
If you were to build the same using Dynamic Linq Queries , you would write
//The parameter expression containing the Entity Type
//cx
ParameterExpression param = Expression.Parameter(typeof(Customers), "cx");
//The Left Hand Side of the Filter Expression
//cx=&gt; cx.City
MemberExpression left = Expression.Property(param, "City");
//The constant to compare against 
ConstantExpression constant = Expression.Constant("London")
//Build the Filter 
//cx=&gt; cx.City == "London"
Expression.Equal( left , constant )
//Build the LambdaExpression to pass to the Where Method
//.Where(cx=&gt; cx.City == "London")
var lambda = Expression.Lambda&lt;Func&lt;Customers, bool&gt;&gt;(filterExpression, param);
//Execute the Filter 
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(lambda);

Now , in the case we just described , the expression just compares the value of city to a constant "City". If we had to create a query comparing the value of City to more constant values , we would have had to create expressions with OR .
Expression filterPredicate = null;
    foreach (var id in set) {
        //Build a comparison expression which equates the Id of the Entity with this value in the IDs list
        // ex : e.Id == 1
        Expression comparison = Expression.Equal(left, Expression.Constant(id));
        //Add this to the complete Filter Expression
       // e.Id == 1 or e.Id == 3
        filterPredicate = (filterPredicate == null) ? comparison : Expression.Or(filterPredicate, comparison);
 }
This is what the complete Function looks like ..
static Expression&lt;Func&lt;Customers, bool&gt;&gt; ContainedInSet(IEnumerable Set, string Property, Type EntityType)
        {
            //The Filter Predicate that contains the Filter criteria
            Expression filterPredicate = null;
            //The parameter expression containing the Entity Type
            ParameterExpression param = Expression.Parameter(EntityType, "l");
            //The Left Hand Side of the Filter Expression
            Expression left = Expression.Property(param, Property);

            //Build a Dynamic Linq Query for finding an entity whose ID is in the list
            foreach (var id in Set) {
                //Build a comparision expression which equats the Id of the ENtity with this value in the IDs list
                // ex : e.Id == 1
                Expression comparison = Expression.Equal(left, Expression.Constant(id));
                //Add this to the complete Filter Expression
                // e.Id == 1 or e.Id == 3
                filterPredicate = (filterPredicate == null) ? comparison : Expression.Or(filterPredicate, comparison);
            }
            //Convert the Filter Expression into a Lambda expression of type Func&lt;Lists,bool&gt;
            // which means that this lambda expression takes an instance of type EntityType and returns a Bool
            var lambdaFilterExpression = Expression.Lambda&lt;Func&lt;Customers, bool&gt;&gt;(filterPredicate, param);
            return lambdaFilterExpression;
        }
But , it's not fun unless its an Extension Method , so we have the complete sample as :

" />
    <meta property="og:description" content="Today's Post is co-Authored by Linq Ninja and my Colleague MarceloLinq to Astoria does not support Set based queries , which means that this query is invalid
List&lt;string&gt; citiesIWillVisit = new List&lt;string&gt;(){
                        "London",
                        "Berlin",
                        "Prague"
                        };
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; citiesIWillVisit.Contains(cx.City));
The above example would use the IN operator to search for a property ina given set of values.You can achieve the same query using Dynamic Linq Queries to filter over a set of values by creating Dynamic Linq Queries at runtime based on your logic and Set .Lets take the same example as before .Of all the Customers in the Northwind store , lets say that you want to visit customers living in citiesthatare on your itinerary.

 List&lt;object&gt; citiesIWillVisit = new List&lt;object&gt;(){
                        "London",
                        "Berlin",
                        "Prague"
                        };
The Customer Entity contains a property called "City" on which we want to filter.if you already know the cities and they wont change , a normal Filter query would look like this 
            //Create the Northwind Client Context
            northwindContext nwContext = new northwindContext(
                new Uri("http://ServiceEndPoint/Northwind.svc")
                );

            var customersAround = from cx in nwContext.Customers
                                  where cx.City == "London"
                                  || cx.City == "Berlin"
                                  || cx.City == "Prague"
                                  select cx;

            foreach (Customers coHabitant in customersAround) {
                System.Console.WriteLine(coHabitant.ContactName);
            }
Now , what if the cities you visit is dynamic ? In such a case you cannot write queries for all possible combinations and expect it to work.Its just too wasteful to do that , there is a better way to do this , Dynamic Filter Expressions.Once you have a dynamic filter expression, you can call the "Where" method on the appropriate DataServiceQuery&lt;T&gt; object to get the results. Lets look at how to build a dynamic filter expression.An Expression has the following basic components.
nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; cx.City == "London")
Parameter : "cx"Left Hand Side Of Expression : cx.CityConstant : "London"
If you were to build the same using Dynamic Linq Queries , you would write
//The parameter expression containing the Entity Type
//cx
ParameterExpression param = Expression.Parameter(typeof(Customers), "cx");
//The Left Hand Side of the Filter Expression
//cx=&gt; cx.City
MemberExpression left = Expression.Property(param, "City");
//The constant to compare against 
ConstantExpression constant = Expression.Constant("London")
//Build the Filter 
//cx=&gt; cx.City == "London"
Expression.Equal( left , constant )
//Build the LambdaExpression to pass to the Where Method
//.Where(cx=&gt; cx.City == "London")
var lambda = Expression.Lambda&lt;Func&lt;Customers, bool&gt;&gt;(filterExpression, param);
//Execute the Filter 
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(lambda);

Now , in the case we just described , the expression just compares the value of city to a constant "City". If we had to create a query comparing the value of City to more constant values , we would have had to create expressions with OR .
Expression filterPredicate = null;
    foreach (var id in set) {
        //Build a comparison expression which equates the Id of the Entity with this value in the IDs list
        // ex : e.Id == 1
        Expression comparison = Expression.Equal(left, Expression.Constant(id));
        //Add this to the complete Filter Expression
       // e.Id == 1 or e.Id == 3
        filterPredicate = (filterPredicate == null) ? comparison : Expression.Or(filterPredicate, comparison);
 }
This is what the complete Function looks like ..
static Expression&lt;Func&lt;Customers, bool&gt;&gt; ContainedInSet(IEnumerable Set, string Property, Type EntityType)
        {
            //The Filter Predicate that contains the Filter criteria
            Expression filterPredicate = null;
            //The parameter expression containing the Entity Type
            ParameterExpression param = Expression.Parameter(EntityType, "l");
            //The Left Hand Side of the Filter Expression
            Expression left = Expression.Property(param, Property);

            //Build a Dynamic Linq Query for finding an entity whose ID is in the list
            foreach (var id in Set) {
                //Build a comparision expression which equats the Id of the ENtity with this value in the IDs list
                // ex : e.Id == 1
                Expression comparison = Expression.Equal(left, Expression.Constant(id));
                //Add this to the complete Filter Expression
                // e.Id == 1 or e.Id == 3
                filterPredicate = (filterPredicate == null) ? comparison : Expression.Or(filterPredicate, comparison);
            }
            //Convert the Filter Expression into a Lambda expression of type Func&lt;Lists,bool&gt;
            // which means that this lambda expression takes an instance of type EntityType and returns a Bool
            var lambdaFilterExpression = Expression.Lambda&lt;Func&lt;Customers, bool&gt;&gt;(filterPredicate, param);
            return lambdaFilterExpression;
        }
But , it's not fun unless its an Extension Method , so we have the complete sample as :

" />
    
    <meta name="author" content="Phani Raj" />

    
    <meta property="og:title" content="Set Based Operations in Ado.net Data Services" />
    <meta property="twitter:title" content="Set Based Operations in Ado.net Data Services" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Phani Raj - Technical Lead at HP Cloud" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/barryclark/jekyll-now/master/images/jekyll-logo.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Phani Raj</a></h1>
            <p class="site-description">Technical Lead at HP Cloud</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Set Based Operations in Ado.net Data Services</h1>

  <div class="entry">
    <p>Today's Post is co-Authored by Linq Ninja and my Colleague <a href="http://blogs.msdn.com/Marcelolr" mce_href="http://blogs.msdn.com/Marcelolr">Marcelo</a><br />Linq to Astoria does not support Set based queries , which means that this query is invalid
<pre class="darkcsharpcode">List&lt;<span class="kwrd">string</span>&gt; citiesIWillVisit = <span class="kwrd">new</span> List&lt;<span class="kwrd">string</span>&gt;(){
                        <span class="str">"London"</span>,
                        <span class="str">"Berlin"</span>,
                        <span class="str">"Prague"</span>
                        };
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; citiesIWillVisit.Contains(cx.City));</pre>
<p>The above example would use the IN operator to search for a property in<br />a given set of values.You can achieve the same query using <br />Dynamic Linq Queries to filter over a set of values by creating Dynamic Linq Queries <br />at runtime based on your logic and Set .Lets take the same example as before .<br />Of all the Customers in the Northwind store , lets say that you want to visit customers living in cities<br />thatare on your itinerary.
<pre></pre>
<pre class="darkcsharpcode"> List&lt;<span class="kwrd">object</span>&gt; citiesIWillVisit = <span class="kwrd">new</span> List&lt;<span class="kwrd">object</span>&gt;(){
                        <span class="str">"London"</span>,
                        <span class="str">"Berlin"</span>,
                        <span class="str">"Prague"</span>
                        };</pre>
<p>The Customer Entity contains a property called "City" on which we want to filter.<br />if you already know the cities and they wont change , a normal Filter query would look like this 
<pre class="darkcsharpcode"><span class="rem">            //Create the Northwind Client Context</span>
            northwindContext nwContext = <span class="kwrd">new</span> northwindContext(
                <span class="kwrd">new</span> Uri(<span class="str">"http://ServiceEndPoint/Northwind.svc"</span>)
                );

            var customersAround = from cx <span class="kwrd">in</span> nwContext.Customers
                                  <span class="kwrd">where</span> cx.City == <span class="str">"London"</span>
                                  || cx.City == <span class="str">"Berlin"</span>
                                  || cx.City == <span class="str">"Prague"</span>
                                  select cx;

            <span class="kwrd">foreach</span> (Customers coHabitant <span class="kwrd">in</span> customersAround) {
                System.Console.WriteLine(coHabitant.ContactName);
            }</pre>
<p>Now , what if the cities you visit is dynamic ? In such a case you cannot write <br />queries for all possible combinations and expect it to work.<br />Its just too wasteful to do that , there is a better way to do this , Dynamic Filter Expressions.<br />Once you have a dynamic filter expression, you can call the "Where" method on <br />the appropriate DataServiceQuery&lt;T&gt; object to get the results. Lets look at how to build a dynamic filter expression.<br />An Expression has the following basic components.
<pre class="darkcsharpcode">nwContext.Customers.Where&lt;Customers&gt;(cx =&gt; cx.City == <span class="str">"London"</span>)</pre>
<pre class="darkcsharpcode">Parameter : "cx"<br /><br />Left Hand Side Of Expression : cx.City<br />Constant : "London"<br /></pre>
<p>If you were to build the same using Dynamic Linq Queries , you would write
<pre class="darkcsharpcode"><span class="rem">//The parameter expression containing the Entity Type</span>
<span class="rem">//cx</span>
ParameterExpression param = Expression.Parameter(<span class="kwrd">typeof</span>(Customers), <span class="str">"cx"</span>);
<span class="rem">//The Left Hand Side of the Filter Expression</span>
<span class="rem">//cx=&gt; cx.City</span>
MemberExpression left = Expression.Property(param, <span class="str">"City"</span>);
<span class="rem">//The constant to compare against </span>
ConstantExpression constant = Expression.Constant(<span class="str">"London"</span>)
<span class="rem">//Build the Filter </span>
<span class="rem">//cx=&gt; cx.City == "London"</span>
Expression.Equal( left , constant )
<span class="rem">//Build the LambdaExpression to pass to the Where Method</span>
<span class="rem">//.Where(cx=&gt; cx.City == "London")</span>
var lambda = Expression.Lambda&lt;Func&lt;Customers, <span class="kwrd">bool</span>&gt;&gt;(filterExpression, param);
<span class="rem">//Execute the Filter </span>
var customersAround = nwContext.Customers.Where&lt;Customers&gt;(lambda);
</pre>
<p>Now , in the case we just described , the expression just compares the value of city to a constant "City". If we had <br />to create a query comparing the value of City to more constant values , we would have had to create expressions with OR .
<pre class="darkcsharpcode">Expression filterPredicate = <span class="kwrd">null</span>;
    <span class="kwrd">foreach</span> (var id <span class="kwrd">in</span> set) {
        <span class="rem">//Build a comparison expression which equates the Id of the Entity with this value in the IDs list</span>
        <span class="rem">// ex : e.Id == 1</span>
        Expression comparison = Expression.Equal(left, Expression.Constant(id));
        <span class="rem">//Add this to the complete Filter Expression</span>
       <span class="rem">// e.Id == 1 or e.Id == 3</span>
        filterPredicate = (filterPredicate == <span class="kwrd">null</span>) ? comparison : Expression.Or(filterPredicate, comparison);
 }</pre>
<p>This is what the complete Function looks like ..
<pre class="darkcsharpcode"><br /><span class="kwrd">static</span> Expression&lt;Func&lt;Customers, <span class="kwrd">bool</span>&gt;&gt; ContainedInSet(<span class="kwrd">IEnumerable </span>Set, <span class="kwrd">string</span> Property, Type EntityType)
        {
            <span class="rem">//The Filter Predicate that contains the Filter criteria</span>
            Expression filterPredicate = <span class="kwrd">null</span>;
            <span class="rem">//The parameter expression containing the Entity Type</span>
            ParameterExpression param = Expression.Parameter(EntityType, <span class="str">"l"</span>);
            <span class="rem">//The Left Hand Side of the Filter Expression</span>
            Expression left = Expression.Property(param, Property);

            <span class="rem">//Build a Dynamic Linq Query for finding an entity whose ID is in the list</span>
            <span class="kwrd">foreach</span> (var id <span class="kwrd">in</span> Set) {
                <span class="rem">//Build a comparision expression which equats the Id of the ENtity with this value in the IDs list</span>
                <span class="rem">// ex : e.Id == 1</span>
                Expression comparison = Expression.Equal(left, Expression.Constant(id));
                <span class="rem">//Add this to the complete Filter Expression</span>
                <span class="rem">// e.Id == 1 or e.Id == 3</span>
                filterPredicate = (filterPredicate == <span class="kwrd">null</span>) ? comparison : Expression.Or(filterPredicate, comparison);
            }
            <span class="rem">//Convert the Filter Expression into a Lambda expression of type Func&lt;Lists,bool&gt;</span>
            <span class="rem">// which means that this lambda expression takes an instance of type EntityType and returns a Bool</span>
            var lambdaFilterExpression = Expression.Lambda&lt;Func&lt;Customers, <span class="kwrd">bool</span>&gt;&gt;(filterPredicate, param);
            <span class="kwrd">return</span> lambdaFilterExpression;
        }</pre>
<p>But , it's not fun unless its an Extension Method , so we have the complete sample as :<br />
<script src="http://gist.github.com/113142.js" mce_src="http://gist.github.com/113142.js"></script></p>

  </div>

  <div class="date">
    Written on July 16, 2008
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/jekyllrb"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
