<!DOCTYPE html>
<html>
  <head>
    <title>ADO.NET Data Services Friendly Feeds , Mapping CLR Types – Phani Raj – Technical Lead at HP Cloud</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="As I mentioned in my last blog post , here are some samples of how to map your entity properties to Atom/custom markup in the atom:entry element.     
You can apply Friendly Feed mappings on the CLR entity types by decorating the Entity classes with the EntityPropertyMappingAttribute type.     We will focus on the kinds of mappings and how to achieve them .     
1) Mapping to ATOM elements in the atom:entry payload :&#160; 
The EntityPropertyMapping (EPM) attribute has two constructors , one which binds the property to an Atom element in the feed ,    and another which binds the property to a custom element . We shall discuss the former in this section. 
For ATOM Mappings , the EPM Attribute constructor takes the following parameters.

propertyName : The property of the Entity Type whose value should be mapped 
targetSyndicationItem : The atom:entry element to which this property has to be mapped to 
targetTextContentKind : The content-type of the mapped&#160; atom:entry element 
keepInContent : set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. 

Lets proceed&#160; , using the same BlogPost&#160; type that we discussed last time .
public class BlogPost
{
    public double Lat { get; set; }
    public double Long { get; set; }
    public int BlogPostID { get; set; }
    public string Title { get; set; }
    public string Body { get; set; }
    public string Author { get; set; }
    public string PostURI { get; set; }
    public string ContentSummary { get; set; }
}

1. Map the “Title” property&#160; of the BlogPost Entity type to the entry:title element
  2. Map the “Author” property to entry:author element&#160; 
This is what the code would look like :
[EntityPropertyMapping(
       &quot;Title&quot;,/*Source property path , the property of the Entity type to be mapped*/
       SyndicationItemProperty.Title,/* Syndication item to which the Source Property is mapped*/
       SyndicationTextContentKind.Plaintext,/* Syndication content kind for the syndication item this property is bound to */
       true/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
       )]
[EntityPropertyMapping(&quot;Author&quot;, SyndicationItemProperty.AuthorName, SyndicationTextContentKind.Plaintext, true)]
public class BlogPost

As described in&#160; my previous blog post , you can map an Entity’s properties to the following atom:entry elements in the payload :



atom:entry Element 
TargetSyndicationItem


entry:author/email 
SyndicationItemProperty.AuthorEmail


entry:author/name
SyndicationItemProperty.AuthorName


entry:author/uri 
SyndicationItemProperty.AuthorUri


entry:published 
SyndicationItemProperty.Published


entry:rights 
SyndicationItemProperty.Rights


entry:summary 
SyndicationItemProperty.Summary


entry:title 
SyndicationItemProperty.Title


entry:Updated
SyndicationItemProperty.Updated


entry:contributor/name
SyndicationItemProperty.ContributorName


entry:contributor/email
SyndicationItemProperty.ContributorEmail


entry:contributor/uri
SyndicationItemProperty.ContributorUri



&#160;
2) Mapping to non-ATOM/custom&#160; elements in the atom:entry payload :&#160; 
For non-ATOM/custom Mappings , the EPM Attribute constructor takes the following parameters.

propertyName : The property of the Entity Type whose value should be mapped 
targetName&#160; (Target Path)&#160;&#160; : The xml path markup which describes the path to the custom markup this property should be mapped to . 
targetNamespacePrefix: The xml prefix for the custom element/attribute that this property is mapped to. 
targetNamespaceUri: The xml namespace to which the custom element/attribute that this property is mapped should be under. 
keepInContent : set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. 


The Xml Path syntax for custom mappings.
this syntax is very logical and looks like the following .
  Lets say that you wanted to map a property to a custom element in markup that looks like this : 
&lt;mycustomRoot xmlns=”http://www.mycustomFormat.org”&gt;
  &lt;customElement&gt;property value goes here&lt;/customElement&gt;
&lt;/mycustomRoot&gt;

for this example ,
targetName&#160; would be “mycustomRoot/customElement”
  targetNamespacePrefix would be an empty string as this markup has no custom prefix.
targetNamespaceUri would be “http://www.mycustomFormat.org”
keepInContent&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not.
and now , lets say that you wanted to map a property to a custom attribute of an element in markup that looks like this : 
&lt;mycustomRoot xmlns:me=&quot;http://www.georss.org.georss&quot;&gt;
  &lt;me:customElement customAttribute=&quot;property value goes here&quot;&gt;&lt;/me:customElement&gt;
&lt;/mycustomRoot&gt;
for this example ,
  targetName&#160; would be “mycustomRoot/customElement/@customAttribute”
targetNamespacePrefix would be “me”.
targetNamespaceUri would be “http://www.mycustomFormat.org”
keepInContent&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not. 
A note , the complexity of your custom markup has a direct effect on the performance costs&#160; for Serialization/De-Serialization of the entity type .
with this ,example , lets map the lat &amp; long properties to geoRss markup ,which looks like this :
  
&lt;geo:lat xmlns:geo=&quot;http://www.georss.org/georss&quot;&gt;47.684&lt;/geo:lat&gt;
&lt;geo:long xmlns:geo=&quot;http://www.georss.org/georss&quot;&gt;-122.122&lt;/geo:long&gt;
Final type definition looks like this :
  
   [EntityPropertyMapping(
        &quot;Title&quot;,/*Source property path , the property of the Entity type to be mapped*/
        SyndicationItemProperty.Title,/* Syndication item to which the Source Property is mapped*/
        SyndicationTextContentKind.Plaintext,/* Syndication content kind for the syndication item this property is bound to */
        true/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
        )]
    [EntityPropertyMapping(&quot;Author&quot;, SyndicationItemProperty.AuthorName, SyndicationTextContentKind.Plaintext, true)]
    [EntityPropertyMapping(&quot;Lat&quot;,/*Source property path , the property of the Entity type to be mapped*/
        &quot;lat&quot;,/*The xml path markup which describes the path to the custom markup this property should be mapped to . */
        &quot;geo&quot;,/*The xml prefix for the custom element/attribute that this property is mapped to. */
        &quot;http://www.georss.org/georss&quot;, /*The xml namespace to which the custom element/attribute that this property is mapped should be under*/
        true /*set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. */
        )]
    [EntityPropertyMapping(&quot;Long&quot;, &quot;long&quot;, &quot;geo&quot;, &quot;http://www.georss.org/georss&quot;, true)]
    public class BlogPost
    {
        public double Lat { get; set; }
        public double Long { get; set; }
        public DateTime Published { get; set; }
        public int BlogPostID { get; set; }
        public string Title { get; set; }
        public string Body { get; set; }
        public string Author { get; set; }
        public string PostURI { get; set; }
        public string ContentSummary{ get;set;   }
        public string IconUri {get;set;}
    }
Special cases 
I . Complex type properties

  Consider the following model , 
public class Address
    {
        public long DoorNumber { get; set; }
        public string Street { get; set; }
        public int ZipCode { get; set; }
    }
    [DataServiceKey(&quot;CustomerID&quot;)]
    public class Customer
    {
        public int CustomerID { get; set; }
        public Address myAddress { get; set; }
    }


  and lets say that you wanted to map the property Street of the complex type Address when accessed through the
entity type “Customer”&#160; to the atom:title element ,
this can be achieved via setting the propertyName property to an appropriate path .
because propertyName not just takes the property name , it also accepts a path to the property’s location.&#160; &#160; in this case , the propertyName would be : “myAddress/Street”&#160; , and the Epm attribute would look like this :
[DataServiceKey(&quot;CustomerID&quot;)]
[EntityPropertyMapping(
        &quot;myAddress/Street&quot;,
        SyndicationItemProperty.Title,
        SyndicationTextContentKind.Plaintext,
        true
        )]
public class Customer
{
   public int CustomerID { get; set; }
   public Address myAddress { get; set; }
}

II Mapping properties declared&#160; on base type
Consider this data model :
[DataServiceKey(&quot;CustomerID&quot;)]
public class Customer
{
        public int CustomerID { get; set; }
        public Address myAddress { get; set; }
        public string BaseTypeField { get; set; }
}

public class DerivedCustomer : Customer
{
  public string DerivedTypeField { get; set; }
}
and you want to map a property declared on the Base type “Customer” on the derived type “DerivedCustomer”
The type declaration would look like this :
[EntityPropertyMapping(&quot;BaseTypeField&quot;, SyndicationItemProperty.Title, SyndicationTextContentKind.Plaintext, true)]
public class DerivedCustomer : Customer {
   public string DerivedTypeField { get; set; }
}
In other words , when specifying the propertyName , property paths always make simple properties look like they are declared
on the type which has annotations , mapping inherited properties is no different from mapping properties declared on the same type. 
Considerations for location&#160; of EPM Attribute 
Use the following guidelines to decide where in the entity model you should add the attribute for either ATOM or custom Mappings,



Where is property defined ?
Where do I apply the EPM attribute?


Simple property on the Entity Type
        ex:
“Title” property of “BlogPost” type above
Entity Type


Simple property on entity’s base type
Derived Entity Type or Base Entity Type


Complex Property on the Entity Type
Complex Types cannot be mapped directly See , 3


Simple property defined on complex type which is a property on an Entity Type
Entity Type



Hope you enjoyed this post about applying Friendly Feeds mappings to CLR data models.
  The next blog post will discuss how to apply the same mappings to EDM models.
" />
    <meta property="og:description" content="As I mentioned in my last blog post , here are some samples of how to map your entity properties to Atom/custom markup in the atom:entry element.     
You can apply Friendly Feed mappings on the CLR entity types by decorating the Entity classes with the EntityPropertyMappingAttribute type.     We will focus on the kinds of mappings and how to achieve them .     
1) Mapping to ATOM elements in the atom:entry payload :&#160; 
The EntityPropertyMapping (EPM) attribute has two constructors , one which binds the property to an Atom element in the feed ,    and another which binds the property to a custom element . We shall discuss the former in this section. 
For ATOM Mappings , the EPM Attribute constructor takes the following parameters.

propertyName : The property of the Entity Type whose value should be mapped 
targetSyndicationItem : The atom:entry element to which this property has to be mapped to 
targetTextContentKind : The content-type of the mapped&#160; atom:entry element 
keepInContent : set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. 

Lets proceed&#160; , using the same BlogPost&#160; type that we discussed last time .
public class BlogPost
{
    public double Lat { get; set; }
    public double Long { get; set; }
    public int BlogPostID { get; set; }
    public string Title { get; set; }
    public string Body { get; set; }
    public string Author { get; set; }
    public string PostURI { get; set; }
    public string ContentSummary { get; set; }
}

1. Map the “Title” property&#160; of the BlogPost Entity type to the entry:title element
  2. Map the “Author” property to entry:author element&#160; 
This is what the code would look like :
[EntityPropertyMapping(
       &quot;Title&quot;,/*Source property path , the property of the Entity type to be mapped*/
       SyndicationItemProperty.Title,/* Syndication item to which the Source Property is mapped*/
       SyndicationTextContentKind.Plaintext,/* Syndication content kind for the syndication item this property is bound to */
       true/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
       )]
[EntityPropertyMapping(&quot;Author&quot;, SyndicationItemProperty.AuthorName, SyndicationTextContentKind.Plaintext, true)]
public class BlogPost

As described in&#160; my previous blog post , you can map an Entity’s properties to the following atom:entry elements in the payload :



atom:entry Element 
TargetSyndicationItem


entry:author/email 
SyndicationItemProperty.AuthorEmail


entry:author/name
SyndicationItemProperty.AuthorName


entry:author/uri 
SyndicationItemProperty.AuthorUri


entry:published 
SyndicationItemProperty.Published


entry:rights 
SyndicationItemProperty.Rights


entry:summary 
SyndicationItemProperty.Summary


entry:title 
SyndicationItemProperty.Title


entry:Updated
SyndicationItemProperty.Updated


entry:contributor/name
SyndicationItemProperty.ContributorName


entry:contributor/email
SyndicationItemProperty.ContributorEmail


entry:contributor/uri
SyndicationItemProperty.ContributorUri



&#160;
2) Mapping to non-ATOM/custom&#160; elements in the atom:entry payload :&#160; 
For non-ATOM/custom Mappings , the EPM Attribute constructor takes the following parameters.

propertyName : The property of the Entity Type whose value should be mapped 
targetName&#160; (Target Path)&#160;&#160; : The xml path markup which describes the path to the custom markup this property should be mapped to . 
targetNamespacePrefix: The xml prefix for the custom element/attribute that this property is mapped to. 
targetNamespaceUri: The xml namespace to which the custom element/attribute that this property is mapped should be under. 
keepInContent : set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. 


The Xml Path syntax for custom mappings.
this syntax is very logical and looks like the following .
  Lets say that you wanted to map a property to a custom element in markup that looks like this : 
&lt;mycustomRoot xmlns=”http://www.mycustomFormat.org”&gt;
  &lt;customElement&gt;property value goes here&lt;/customElement&gt;
&lt;/mycustomRoot&gt;

for this example ,
targetName&#160; would be “mycustomRoot/customElement”
  targetNamespacePrefix would be an empty string as this markup has no custom prefix.
targetNamespaceUri would be “http://www.mycustomFormat.org”
keepInContent&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not.
and now , lets say that you wanted to map a property to a custom attribute of an element in markup that looks like this : 
&lt;mycustomRoot xmlns:me=&quot;http://www.georss.org.georss&quot;&gt;
  &lt;me:customElement customAttribute=&quot;property value goes here&quot;&gt;&lt;/me:customElement&gt;
&lt;/mycustomRoot&gt;
for this example ,
  targetName&#160; would be “mycustomRoot/customElement/@customAttribute”
targetNamespacePrefix would be “me”.
targetNamespaceUri would be “http://www.mycustomFormat.org”
keepInContent&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not. 
A note , the complexity of your custom markup has a direct effect on the performance costs&#160; for Serialization/De-Serialization of the entity type .
with this ,example , lets map the lat &amp; long properties to geoRss markup ,which looks like this :
  
&lt;geo:lat xmlns:geo=&quot;http://www.georss.org/georss&quot;&gt;47.684&lt;/geo:lat&gt;
&lt;geo:long xmlns:geo=&quot;http://www.georss.org/georss&quot;&gt;-122.122&lt;/geo:long&gt;
Final type definition looks like this :
  
   [EntityPropertyMapping(
        &quot;Title&quot;,/*Source property path , the property of the Entity type to be mapped*/
        SyndicationItemProperty.Title,/* Syndication item to which the Source Property is mapped*/
        SyndicationTextContentKind.Plaintext,/* Syndication content kind for the syndication item this property is bound to */
        true/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
        )]
    [EntityPropertyMapping(&quot;Author&quot;, SyndicationItemProperty.AuthorName, SyndicationTextContentKind.Plaintext, true)]
    [EntityPropertyMapping(&quot;Lat&quot;,/*Source property path , the property of the Entity type to be mapped*/
        &quot;lat&quot;,/*The xml path markup which describes the path to the custom markup this property should be mapped to . */
        &quot;geo&quot;,/*The xml prefix for the custom element/attribute that this property is mapped to. */
        &quot;http://www.georss.org/georss&quot;, /*The xml namespace to which the custom element/attribute that this property is mapped should be under*/
        true /*set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. */
        )]
    [EntityPropertyMapping(&quot;Long&quot;, &quot;long&quot;, &quot;geo&quot;, &quot;http://www.georss.org/georss&quot;, true)]
    public class BlogPost
    {
        public double Lat { get; set; }
        public double Long { get; set; }
        public DateTime Published { get; set; }
        public int BlogPostID { get; set; }
        public string Title { get; set; }
        public string Body { get; set; }
        public string Author { get; set; }
        public string PostURI { get; set; }
        public string ContentSummary{ get;set;   }
        public string IconUri {get;set;}
    }
Special cases 
I . Complex type properties

  Consider the following model , 
public class Address
    {
        public long DoorNumber { get; set; }
        public string Street { get; set; }
        public int ZipCode { get; set; }
    }
    [DataServiceKey(&quot;CustomerID&quot;)]
    public class Customer
    {
        public int CustomerID { get; set; }
        public Address myAddress { get; set; }
    }


  and lets say that you wanted to map the property Street of the complex type Address when accessed through the
entity type “Customer”&#160; to the atom:title element ,
this can be achieved via setting the propertyName property to an appropriate path .
because propertyName not just takes the property name , it also accepts a path to the property’s location.&#160; &#160; in this case , the propertyName would be : “myAddress/Street”&#160; , and the Epm attribute would look like this :
[DataServiceKey(&quot;CustomerID&quot;)]
[EntityPropertyMapping(
        &quot;myAddress/Street&quot;,
        SyndicationItemProperty.Title,
        SyndicationTextContentKind.Plaintext,
        true
        )]
public class Customer
{
   public int CustomerID { get; set; }
   public Address myAddress { get; set; }
}

II Mapping properties declared&#160; on base type
Consider this data model :
[DataServiceKey(&quot;CustomerID&quot;)]
public class Customer
{
        public int CustomerID { get; set; }
        public Address myAddress { get; set; }
        public string BaseTypeField { get; set; }
}

public class DerivedCustomer : Customer
{
  public string DerivedTypeField { get; set; }
}
and you want to map a property declared on the Base type “Customer” on the derived type “DerivedCustomer”
The type declaration would look like this :
[EntityPropertyMapping(&quot;BaseTypeField&quot;, SyndicationItemProperty.Title, SyndicationTextContentKind.Plaintext, true)]
public class DerivedCustomer : Customer {
   public string DerivedTypeField { get; set; }
}
In other words , when specifying the propertyName , property paths always make simple properties look like they are declared
on the type which has annotations , mapping inherited properties is no different from mapping properties declared on the same type. 
Considerations for location&#160; of EPM Attribute 
Use the following guidelines to decide where in the entity model you should add the attribute for either ATOM or custom Mappings,



Where is property defined ?
Where do I apply the EPM attribute?


Simple property on the Entity Type
        ex:
“Title” property of “BlogPost” type above
Entity Type


Simple property on entity’s base type
Derived Entity Type or Base Entity Type


Complex Property on the Entity Type
Complex Types cannot be mapped directly See , 3


Simple property defined on complex type which is a property on an Entity Type
Entity Type



Hope you enjoyed this post about applying Friendly Feeds mappings to CLR data models.
  The next blog post will discuss how to apply the same mappings to EDM models.
" />
    
    <meta name="author" content="Phani Raj" />

    
    <meta property="og:title" content="ADO.NET Data Services Friendly Feeds , Mapping CLR Types" />
    <meta property="twitter:title" content="ADO.NET Data Services Friendly Feeds , Mapping CLR Types" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Phani Raj - Technical Lead at HP Cloud" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/barryclark/jekyll-now/master/images/jekyll-logo.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Phani Raj</a></h1>
            <p class="site-description">Technical Lead at HP Cloud</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>ADO.NET Data Services Friendly Feeds , Mapping CLR Types</h1>

  <div class="entry">
    <p>As I mentioned in my <a href="http://blogs.msdn.com/phaniraj/archive/2009/03/18/introducing-web-friendly-feeds-aka-friendly-feeds.aspx">last blog post</a> , here are some samples of how to map your entity properties to Atom/custom markup in the atom:entry element.     </p>
<p>You can apply Friendly Feed mappings on the CLR entity types by decorating the Entity classes with the EntityPropertyMappingAttribute type.     <br />We will focus on the kinds of mappings and how to achieve them .     </p>
<p><strong>1) Mapping to ATOM elements in the atom:entry payload :&#160; <br /></strong></p>
<p>The EntityPropertyMapping (EPM) attribute has two constructors , one which binds the property to an Atom element in the feed ,    <br />and another which binds the property to a custom element . We shall discuss the former in this section. </p>
<p>For ATOM Mappings , the EPM Attribute constructor takes the following parameters.</p>
<ol>
<li><strong>propertyName </strong>: The property of the Entity Type whose value should be mapped </li>
<li><strong>targetSyndicationItem </strong>: The atom:entry element to which this property has to be mapped to </li>
<li><strong>targetTextContentKind </strong>: The content-type of the mapped&#160; atom:entry element </li>
<li><strong>keepInContent </strong>: set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. </li>
</ol>
<p>Lets proceed&#160; , using the same BlogPost&#160; type that we <a href="http://blogs.msdn.com/phaniraj/archive/2009/03/18/introducing-web-friendly-feeds-aka-friendly-feeds.aspx">discussed last time</a> .</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">BlogPost
</span>{
    <span style="color: blue">public double </span>Lat { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public double </span>Long { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public int </span>BlogPostID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>Title { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>Body { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>Author { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>PostURI { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    <span style="color: blue">public string </span>ContentSummary { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>1. Map the “Title” property&#160; of the BlogPost Entity type to the entry:title element<br />
  <br />2. Map the “Author” property to entry:author element&#160; </p>
<p>This is what the code would look like :</p>
<pre class="code">[<span style="color: #2b91af">EntityPropertyMapping</span>(
       <span style="color: #a31515">&quot;Title&quot;</span>,<span style="color: green">/*Source property path , the property of the Entity type to be mapped*/
       </span><span style="color: #2b91af">SyndicationItemProperty</span>.Title,<span style="color: green">/* Syndication item to which the Source Property is mapped*/
       </span><span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext,<span style="color: green">/* Syndication content kind for the syndication item this property is bound to */
       </span><span style="color: blue">true</span><span style="color: green">/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
       </span>)]
[<span style="color: #2b91af">EntityPropertyMapping</span>(<span style="color: #a31515">&quot;Author&quot;</span>, <span style="color: #2b91af">SyndicationItemProperty</span>.AuthorName, <span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext, <span style="color: blue">true</span>)]
<span style="color: blue">public class </span><span style="color: #2b91af">BlogPost</span></pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>As described in&#160; my previous blog post , you can map an Entity’s properties to the following atom:entry elements in the payload <strong>:</strong></p>
<table border="0" cellspacing="0" cellpadding="2" width="512">
<tbody>
<tr>
<td valign="top" width="200"><strong>atom:entry Element </strong></td>
<td valign="top" width="310"><strong>TargetSyndicationItem</strong></td>
</tr>
<tr>
<td valign="top" width="200">entry:author/email </td>
<td valign="top" width="310">SyndicationItemProperty.AuthorEmail</td>
</tr>
<tr>
<td valign="top" width="200">entry:author/name</td>
<td valign="top" width="310">SyndicationItemProperty.AuthorName</td>
</tr>
<tr>
<td valign="top" width="200">entry:author/uri </td>
<td valign="top" width="310">SyndicationItemProperty.AuthorUri</td>
</tr>
<tr>
<td valign="top" width="200">entry:published </td>
<td valign="top" width="310">SyndicationItemProperty.Published</td>
</tr>
<tr>
<td valign="top" width="200">entry:rights </td>
<td valign="top" width="310">SyndicationItemProperty.Rights</td>
</tr>
<tr>
<td valign="top" width="200">entry:summary </td>
<td valign="top" width="310">SyndicationItemProperty.Summary</td>
</tr>
<tr>
<td valign="top" width="200">entry:title </td>
<td valign="top" width="310">SyndicationItemProperty.Title</td>
</tr>
<tr>
<td valign="top" width="200">entry:Updated</td>
<td valign="top" width="310">SyndicationItemProperty.Updated</td>
</tr>
<tr>
<td valign="top" width="200">entry:contributor/name</td>
<td valign="top" width="310">SyndicationItemProperty.ContributorName</td>
</tr>
<tr>
<td valign="top" width="200">entry:contributor/email</td>
<td valign="top" width="310">SyndicationItemProperty.ContributorEmail</td>
</tr>
<tr>
<td valign="top" width="200">entry:contributor/uri</td>
<td valign="top" width="310">SyndicationItemProperty.ContributorUri</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<p><strong>2) Mapping to non-ATOM/custom&#160; elements in the atom:entry payload :&#160; </strong></p>
<p>For non-ATOM/custom Mappings , the EPM Attribute constructor takes the following parameters.</p>
<ol>
<li><strong>propertyName</strong> : The property of the Entity Type whose value should be mapped </li>
<li><strong>targetName</strong>&#160; (<strong>Target Path</strong>)&#160;&#160; : The xml path markup which describes the path to the custom markup this property should be mapped to . </li>
<li><strong>targetNamespacePrefix</strong>: The xml prefix for the custom element/attribute that this property is mapped to. </li>
<li><strong>targetNamespaceUri</strong>: The xml namespace to which the custom element/attribute that this property is mapped should be under. </li>
<li><strong>keepInContent </strong>: set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. </li>
</ol>
<p><strong></strong></p>
<p><strong>The Xml Path syntax for custom mappings.</strong></p>
<p>this syntax is very logical and looks like the following .<br />
  <br />Lets say that you wanted to map a property to a custom element in markup that looks like this : </p>
<pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">mycustomRoot</span> <span class="attr">xmlns</span><span class="kwrd">=”<a href="http://www.mycustomFormat.org">http://www.mycustomFormat.org</a>”</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">customElement</span><span class="kwrd">&gt;</span>property value goes here<span class="kwrd">&lt;/</span><span class="html">customElement</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">mycustomRoot</span><span class="kwrd">&gt;</span></pre>
<style type="text/css">
<p>.csharpcode, .csharpcode pre<br />
{<br />
	font-size: small;<br />
	color: black;<br />
	font-family: consolas, "Courier New", courier, monospace;<br />
	background-color: #ffffff;<br />
	/*white-space: pre;*/<br />
}<br />
.csharpcode pre { margin: 0em; }<br />
.csharpcode .rem { color: #008000; }<br />
.csharpcode .kwrd { color: #0000ff; }<br />
.csharpcode .str { color: #006080; }<br />
.csharpcode .op { color: #0000c0; }<br />
.csharpcode .preproc { color: #cc6633; }<br />
.csharpcode .asp { background-color: #ffff00; }<br />
.csharpcode .html { color: #800000; }<br />
.csharpcode .attr { color: #ff0000; }<br />
.csharpcode .alt<br />
{<br />
	background-color: #f4f4f4;<br />
	width: 100%;<br />
	margin: 0em;<br />
}<br />
.csharpcode .lnum { color: #606060; }</style>
<p>for this example ,</p>
<p><strong>targetName</strong>&#160; would be “<span class="html">mycustomRoot</span>/<span>customElement”<br />
  <br /><strong>targetNamespacePrefix</strong> would be an empty string as this markup has no custom prefix.</p>
<p><strong>targetNamespaceUri </strong>would be “<a href="http://www.mycustomFormat.org">http://www.mycustomFormat.org</a>”</p>
<p><strong>keepInContent</strong>&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not.</span></p>
<p>and now , lets say that you wanted to map a property to a custom attribute of an element in markup that looks like this : </p>
<pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">mycustomRoot</span> <span class="attr">xmlns:me</span><span class="kwrd">=&quot;http://www.georss.org.georss&quot;</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;me:</span><span class="html">customElement</span> <span class="attr">customAttribute</span><span class="kwrd">=&quot;property value goes here&quot;</span><span class="kwrd">&gt;&lt;/me:</span><span class="html">customElement</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">mycustomRoot</span><span class="kwrd">&gt;</span></pre>
<p>for this example ,<br />
  <br /><strong>targetName</strong>&#160; would be <a href="mailto:&ldquo;mycustomRoot/customElement/@customAttribute">“mycustomRoot/customElement/@customAttribute</a>”</p>
<p><strong>targetNamespacePrefix</strong> would be “me”.</p>
<p><strong>targetNamespaceUri </strong>would be “http://www.mycustomFormat.org”</p>
<p><strong>keepInContent</strong>&#160; is subjective to whether you want to keep the property value in the &lt;content&gt; section or not. </p>
<p>A note , the complexity of your custom markup has a direct effect on the performance costs&#160; for Serialization/De-Serialization of the entity type .</p>
<p>with this ,example , lets map the lat &amp; long properties to geoRss markup ,which looks like this :<br />
  </p>
<pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">geo:lat</span> <span class="attr">xmlns:geo</span><span class="kwrd">=&quot;http://www.georss.org/georss&quot;</span><span class="kwrd">&gt;</span>47.684<span class="kwrd">&lt;/</span><span class="html">geo:lat</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;</span><span class="html">geo:long</span> <span class="attr">xmlns:geo</span><span class="kwrd">=&quot;http://www.georss.org/georss&quot;</span><span class="kwrd">&gt;</span>-122.122<span class="kwrd">&lt;/</span><span class="html">geo:long</span><span class="kwrd">&gt;</span></pre>
<p>Final type definition looks like this :<br />
  </p>
<pre class="code">   [<span style="color: #2b91af">EntityPropertyMapping</span>(
        <span style="color: #a31515">&quot;Title&quot;</span>,<span style="color: green">/*Source property path , the property of the Entity type to be mapped*/
        </span><span style="color: #2b91af">SyndicationItemProperty</span>.Title,<span style="color: green">/* Syndication item to which the Source Property is mapped*/
        </span><span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext,<span style="color: green">/* Syndication content kind for the syndication item this property is bound to */
        </span><span style="color: blue">true</span><span style="color: green">/* If  false the property value is only placed at the mapped location &amp; removed from the &lt;content&gt; section of the atom:entry*/
        </span>)]
    [<span style="color: #2b91af">EntityPropertyMapping</span>(<span style="color: #a31515">&quot;Author&quot;</span>, <span style="color: #2b91af">SyndicationItemProperty</span>.AuthorName, <span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext, <span style="color: blue">true</span>)]
    [<span style="color: #2b91af">EntityPropertyMapping</span>(<span style="color: #a31515">&quot;Lat&quot;</span>,<span style="color: green">/*Source property path , the property of the Entity type to be mapped*/
        </span><span style="color: #a31515">&quot;lat&quot;</span>,<span style="color: green">/*The xml path markup which describes the path to the custom markup this property should be mapped to . */
        </span><span style="color: #a31515">&quot;geo&quot;</span>,<span style="color: green">/*The xml prefix for the custom element/attribute that this property is mapped to. */
        </span><span style="color: #a31515">&quot;http://www.georss.org/georss&quot;</span>, <span style="color: green">/*The xml namespace to which the custom element/attribute that this property is mapped should be under*/
        </span><span style="color: blue">true </span><span style="color: green">/*set this to false if you want the entity’s property value to turn up only in the mapped atom:entry element and not in the &lt;contents&gt; section. */
        </span>)]
    [<span style="color: #2b91af">EntityPropertyMapping</span>(<span style="color: #a31515">&quot;Long&quot;</span>, <span style="color: #a31515">&quot;long&quot;</span>, <span style="color: #a31515">&quot;geo&quot;</span>, <span style="color: #a31515">&quot;http://www.georss.org/georss&quot;</span>, <span style="color: blue">true</span>)]
    <span style="color: blue">public class </span><span style="color: #2b91af">BlogPost
    </span>{
        <span style="color: blue">public double </span>Lat { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public double </span>Long { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public </span><span style="color: #2b91af">DateTime </span>Published { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public int </span>BlogPostID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>Title { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>Body { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>Author { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>PostURI { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>ContentSummary{ get;set;   }
        <span style="color: blue">public string </span>IconUri {get;set;}<span style="color: green">
    </span>}</pre>
<p><strong>Special cases </strong></p>
<p><strong>I . Complex type properties</strong></p>
<p>
  <br />Consider the following model , </p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">Address
    </span>{
        <span style="color: blue">public long </span>DoorNumber { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>Street { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public int </span>ZipCode { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    }
    [<span style="color: #2b91af">DataServiceKey</span>(<span style="color: #a31515">&quot;CustomerID&quot;</span>)]
    <span style="color: blue">public class </span><span style="color: #2b91af">Customer
    </span>{
        <span style="color: blue">public int </span>CustomerID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public </span><span style="color: #2b91af">Address </span>myAddress { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
    }</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>
  <br />and lets say that you wanted to map the property Street of the complex type Address when accessed through the</p>
<p>entity type “Customer”&#160; to the atom:title element ,</p>
<p>this can be achieved via setting the <strong>propertyName </strong>property to an appropriate path .</p>
<p>because <strong>propertyName </strong>not just takes the property name , it also accepts a path to the property’s location.&#160; <br />&#160; <br />in this case , the <strong>propertyName </strong>would be : “<strong>myAddress/Street</strong>”&#160; , and the Epm attribute would look like this :</p>
<pre class="code">[<span style="color: #2b91af">DataServiceKey</span>(<span style="color: #a31515">&quot;CustomerID&quot;</span>)]
[<span style="color: #2b91af">EntityPropertyMapping</span>(
        <span style="color: #a31515">&quot;myAddress/Street&quot;</span>,
        <span style="color: #2b91af">SyndicationItemProperty</span>.Title,
        <span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext,
        <span style="color: blue">true
        </span>)]
<span style="color: blue">public class </span><span style="color: #2b91af">Customer
</span>{
   <span style="color: blue">public int </span>CustomerID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
   <span style="color: blue">public </span><span style="color: #2b91af">Address </span>myAddress { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></p>
<p><strong>II Mapping properties declared&#160; on base type</p>
<p></strong>Consider this data model :</p>
<pre class="code">[<span style="color: #2b91af">DataServiceKey</span>(<span style="color: #a31515">&quot;CustomerID&quot;</span>)]
<span style="color: blue">public class </span><span style="color: #2b91af">Customer
</span>{
        <span style="color: blue">public int </span>CustomerID { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public </span><span style="color: #2b91af">Address </span>myAddress { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
        <span style="color: blue">public string </span>BaseTypeField { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}

<span style="color: blue">public class </span><span style="color: #2b91af">DerivedCustomer </span>: <span style="color: #2b91af">Customer
</span>{
  <span style="color: blue">public string </span>DerivedTypeField { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p>and you want to map a property declared on the Base type “Customer” on the derived type “DerivedCustomer”</p>
<p>The type declaration would look like this :</p>
<pre class="code">[<span style="color: #2b91af">EntityPropertyMapping</span>(<span style="color: #a31515">&quot;BaseTypeField&quot;</span>, <span style="color: #2b91af">SyndicationItemProperty</span>.Title, <span style="color: #2b91af">SyndicationTextContentKind</span>.Plaintext, <span style="color: blue">true</span>)]
<span style="color: blue">public class </span><span style="color: #2b91af">DerivedCustomer </span>: <span style="color: #2b91af">Customer </span>{
   <span style="color: blue">public string </span>DerivedTypeField { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p>In other words , when specifying the propertyName , property paths always make simple properties look like they are declared</p>
<p>on the type which has annotations , mapping inherited properties is no different from mapping properties declared on the same type. <a href="http://11011.net/software/vspaste"></a><strong></strong></p>
<p><strong>Considerations for location&#160; of EPM Attribute </strong></p>
<p>Use the following guidelines to decide where in the entity model you should add the attribute for either ATOM or custom Mappings,</p>
<table border="0" cellspacing="0" cellpadding="2" width="647">
<tbody>
<tr>
<td valign="top" width="261"><strong>Where is property defined ?</strong></td>
<td valign="top" width="384"><strong>Where do I apply the EPM attribute?</strong></td>
</tr>
<tr>
<td valign="top" width="271">Simple property on the Entity Type<br />
        <br />ex:</p>
<p>“Title” property of “BlogPost” type above</td>
<td valign="top" width="384">Entity Type</td>
</tr>
<tr>
<td valign="top" width="271">Simple property on entity’s base type</td>
<td valign="top" width="384">Derived Entity Type or Base Entity Type</td>
</tr>
<tr>
<td valign="top" width="271">Complex Property on the Entity Type</td>
<td valign="top" width="384">Complex Types cannot be mapped directly See , 3</td>
</tr>
<tr>
<td valign="top" width="271">Simple property defined on complex type which is a property on an Entity Type</td>
<td valign="top" width="384">Entity Type</td>
</tr>
</tbody>
</table>
<p>Hope you enjoyed this post about applying Friendly Feeds mappings to CLR data models.<br />
  <br />The next blog post will discuss how to apply the same mappings to EDM models.</p>

  </div>

  <div class="date">
    Written on March 21, 2009
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/jekyllrb"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    

  </body>
</html>
